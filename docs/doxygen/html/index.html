<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>work-stealing-thread-pool: Work-Stealing Thread Pool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">work-stealing-thread-pool
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('index.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Work-Stealing Thread Pool </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1 class="doxsection"><a class="anchor" id="overview"></a>
Project Overview</h1>
<p>This project implements a high-performance, work-stealing thread pool in modern C++20. It demonstrates advanced concurrent programming techniques combined with a practical real-world use case: parallel 3D volumetric image filtering for medical imaging and scientific computing applications.</p>
<p>The thread pool uses a <b>work-stealing queue</b> architecture where each worker thread maintains its own task deque. Owner threads perform LIFO (stack-like) operations for cache locality, while other threads "steal" work in FIFO (queue-like) order when idle. This design achieves excellent load balancing with minimal contention.</p>
<h1 class="doxsection"><a class="anchor" id="features"></a>
Key Features</h1>
<ul>
<li><b>Work-Stealing Architecture:</b> Each thread has a local task deque for locality; idle threads steal from peers for dynamic load balancing.</li>
<li><b>C++20 Structured Concurrency:</b> Uses <span class="tt">std::jthread</span> for automatic thread joining and <span class="tt">std::stop_token</span> for cooperative cancellation.</li>
<li><b>Thread-Safe Queues:</b> Custom <span class="tt"><a class="el" href="classThreadSafeDeque.html" title="Thread-safe work-stealing deque template.">ThreadSafeDeque</a></span> with condition variables for blocking and non-blocking operations.</li>
<li><b>3D Volumetric Convolution:</b> Complete implementation of parallel 3D image filtering with multiple kernel types (Gaussian blur, Laplacian, directional edge detection).</li>
<li><b>Production-Ready:</b> Proper RAII semantics, graceful shutdown, and comprehensive error handling.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="modern_cpp"></a>
Modern C++ Features Applied</h1>
<h3 class="doxsection"><a class="anchor" id="autotoc_md0"></a>
C++20 Features</h3>
<ul>
<li><b><span class="tt">std::jthread</span>:</b> Joinable threads with automatic cleanup via RAII. No manual <span class="tt">join()</span> calls needed—threads automatically join in the destructor.<ul>
<li>Used in: <a class="el" href="classThreadPool.html" title="Work-stealing thread pool for parallel task execution.">ThreadPool</a> worker management</li>
<li>Benefit: Eliminates resource leaks and simplifies shutdown logic</li>
</ul>
</li>
<li><b><span class="tt">std::stop_token</span> &amp; <span class="tt">std::stop_source</span>:</b> Cooperative cancellation mechanism for safe thread shutdown.<ul>
<li>Used in: Worker thread termination signals</li>
<li>Benefit: Graceful, non-abrupt shutdown with predictable behavior</li>
</ul>
</li>
<li><b><span class="tt">std::atomic&lt;T&gt;</span>:</b> Lock-free synchronization primitives for counters and flags.<ul>
<li>Used in: Task completion tracking and done_ flag</li>
<li>Benefit: Minimal overhead synchronization without full mutex locks</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1"></a>
C++17 &amp; Earlier (Retroactively Used)</h3>
<ul>
<li><b><span class="tt">std::unique_ptr&lt;T[]&gt;</span>:</b> Dynamic arrays with automatic memory management.<ul>
<li>Used in: <span class="tt">work_queues</span> array (one per thread)</li>
<li>Benefit: No manual <span class="tt">delete[]</span>, exception-safe initialization</li>
</ul>
</li>
<li><b><span class="tt">std::unique_ptr&lt;T&gt;</span>:</b> For task ownership within deques.<ul>
<li>Used in: Storing tasks in <a class="el" href="classThreadSafeDeque.html" title="Thread-safe work-stealing deque template.">ThreadSafeDeque</a></li>
<li>Benefit: Clear ownership semantics, move-friendly, automatic cleanup</li>
</ul>
</li>
<li><b>Move Semantics &amp; Perfect Forwarding:</b> Efficient task and data transfer without copies.<ul>
<li>Used in: Task submission, deque operations</li>
<li>Benefit: Zero-copy scheduling, optimal performance</li>
</ul>
</li>
<li><b><span class="tt">std::condition_variable</span>:</b> Synchronization for blocking waits.<ul>
<li>Used in: <a class="el" href="classThreadSafeDeque.html" title="Thread-safe work-stealing deque template.">ThreadSafeDeque</a>'s push/pop operations</li>
<li>Benefit: Efficient thread parking and waking</li>
</ul>
</li>
<li><b><span class="tt">std::mutex</span>:</b> Traditional mutual exclusion for shared data.<ul>
<li>Used in: Protecting deque contents and RNG</li>
<li>Benefit: Data race prevention, clear critical sections</li>
</ul>
</li>
<li><b>Structured Bindings &amp; Auto Types:</b> Cleaner, more concise code.<ul>
<li>Used in: Loop variables, template deduction</li>
<li>Benefit: Reduced boilerplate, improved readability</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md2"></a>
Design Patterns</h3>
<ul>
<li><b>Command Pattern:</b> <a class="el" href="classConvolutionTask.html" title="Command object (Functor) for executing 3D convolution on depth slices.">ConvolutionTask</a> encapsulates a unit of work (functor).</li>
<li><b>RAII (Resource Acquisition Is Initialization):</b> All resources (threads, queues, memory) are tied to object lifetime—no manual cleanup needed.</li>
<li><b>Lock-Free Design (Where Possible):</b> Atomic counters for progress tracking minimize contention.</li>
<li><b>Thread Pool Pattern:</b> Reusable worker threads for amortized scheduling overhead.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="use_case"></a>
3D Volumetric Convolution Use Case</h1>
<h3 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
What is 3D Convolution?</h3>
<p>3D convolution is a fundamental operation in scientific computing and medical imaging. It applies a small 3x3x3 kernel (filter) to every voxel in a 3D volume, computing a weighted sum of the voxel and its neighbors. Applications include:</p>
<ul>
<li><b>Medical Imaging:</b> MRI/CT scan denoising, edge detection for surgical planning</li>
<li><b>Scientific Simulation:</b> Diffusion equations, filter smoothing for numerical stability</li>
<li><b>Computer Vision:</b> 3D object detection, feature extraction from volumetric data</li>
<li><b>Geophysics:</b> Seismic data processing, underground resource mapping</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
The Problem</h3>
<p>A naive sequential convolution on a 24×24×24 volume with a 3x3x3 kernel requires:</p><ul>
<li>~22³ = 10,648 voxel operations</li>
<li>For each voxel: 27 multiplications + 26 additions (kernel size³)</li>
<li><b>Total: ~286,000+ floating-point operations</b></li>
</ul>
<p>On larger real-world volumes (512×512×512 or more), this becomes prohibitively slow.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
The Solution: Parallel 3D Convolution</h3>
<p>This project demonstrates how the work-stealing thread pool efficiently parallelizes 3D convolution:</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
Task Decomposition</h4>
<ul>
<li>The 3D volume is sliced along the z-axis (depth).</li>
<li>Each z-slice is one task: <span class="tt"><a class="el" href="classConvolutionTask.html" title="Command object (Functor) for executing 3D convolution on depth slices.">ConvolutionTask(z_start, z_end)</a></span>.</li>
<li>For a 24×24×24 volume: 22 independent convolution tasks (excluding borders).</li>
<li>Each task is submitted to a random thread's queue.</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7"></a>
Work Distribution</h4>
<ul>
<li><b>If a thread has local work:</b> Execute LIFO (stack order) from its own queue.<ul>
<li>Benefits: Cache warm data, reduced memory traffic.</li>
</ul>
</li>
<li><b>If idle:</b> Steal from a random peer's queue in FIFO order.<ul>
<li>Benefits: Load balancing, no busy-spinning.</li>
</ul>
</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md8"></a>
Synchronization</h4>
<ul>
<li>An atomic counter tracks completed z-slices.</li>
<li>Main thread polls the counter with a lightweight sleep (1ms).</li>
<li>When counter reaches expected value, all work is done.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9"></a>
Filters Implemented</h3>
<p>Three filter types demonstrate the framework's generality:</p>
<ol type="1">
<li><b>Gaussian Blur (3x3x3 Uniform Average)</b><ul>
<li>Kernel: All weights = 1/27</li>
<li>Effect: Smoothing, noise reduction</li>
<li>Use case: Pre-filtering for robust feature extraction</li>
</ul>
</li>
<li><b>Laplacian Edge Detector</b><ul>
<li>Kernel: Center = 6, neighbors = -1</li>
<li>Effect: Highlights high-curvature regions and edges</li>
<li>Use case: Identifying boundaries between tissues</li>
</ul>
</li>
<li><b>Z-Axis Edge Detector (Directional)</b><ul>
<li>Kernel: Front voxel = +1, back voxel = -1, rest = 0</li>
<li>Effect: Detects depth-wise discontinuities</li>
<li>Use case: Layered structure detection</li>
</ul>
</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10"></a>
Input Data Synthesis</h3>
<p>The demo generates a realistic synthetic 3D volume:</p><ul>
<li><b>Background:</b> 10.0 (low intensity)</li>
<li><b>Central Cube:</b> 100.0 (z=5 to 19, y=5 to 19, x=5 to 19)</li>
<li><b>Gaussian Noise:</b> Mean=0, StdDev=8 (added everywhere for realism)</li>
</ul>
<p>This simulates a medical imaging scenario (e.g., tumor in background tissue with noise).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md11"></a>
Performance Metrics</h3>
<p>The program outputs:</p><ul>
<li><b>Thread count:</b> Based on hardware concurrency (capped at 4 for demo)</li>
<li><b>Task count:</b> Number of z-slices processed</li>
<li><b>Execution time:</b> Milliseconds for parallel filtering</li>
<li><b>Sample values:</b> Center and edge voxel results for verification</li>
<li><b>Noise analysis:</b> Standard deviation before/after filtering (for blur kernel)</li>
</ul>
<p>On a modern multi-core system, the work-stealing pool typically achieves:</p><ul>
<li><b>90%+ utilization</b> of available cores</li>
<li><b>Near-linear speedup</b> with thread count (up to core count)</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="architecture"></a>
Project Architecture</h1>
<div class="fragment"><div class="line"><a class="code hl_class" href="classThreadPool.html">ThreadPool</a></div>
<div class="line">├── Worker threads (jthreads)</div>
<div class="line">├── Work queues (<a class="code hl_class" href="classThreadSafeDeque.html">ThreadSafeDeque</a>)</div>
<div class="line">│   ├── Mutex (mut_)</div>
<div class="line">│   ├── Condition variables (cv_not_empty_, cv_not_full_)</div>
<div class="line">│   └── std::deque&lt;std::unique_ptr&lt;TaskFunc&gt;&gt;</div>
<div class="line">└── RNG <span class="keywordflow">for</span> work stealing</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classConvolutionTask.html">ConvolutionTask</a> (Functor)</div>
<div class="line">├── Input &amp; output volumes (references)</div>
<div class="line">├── Kernel weights (reference)</div>
<div class="line">├── Slice range (z_start, z_end)</div>
<div class="line">└── Completion counter (atomic reference)</div>
<div class="line"> </div>
<div class="line">Main Program</div>
<div class="line">├── Initialize <a class="code hl_class" href="classThreadPool.html">ThreadPool</a></div>
<div class="line">├── Create 24×24×24 volume with cube + noise</div>
<div class="line">├── Submit convolution tasks <span class="keywordflow">for each</span> filter</div>
<div class="line">├── Wait <span class="keywordflow">for</span> completion</div>
<div class="line">└── Print results</div>
<div class="ttc" id="aclassConvolutionTask_html"><div class="ttname"><a href="classConvolutionTask.html">ConvolutionTask</a></div><div class="ttdoc">Command object (Functor) for executing 3D convolution on depth slices.</div><div class="ttdef"><b>Definition</b> convolution.hpp:91</div></div>
<div class="ttc" id="aclassThreadPool_html"><div class="ttname"><a href="classThreadPool.html">ThreadPool</a></div><div class="ttdoc">Work-stealing thread pool for parallel task execution.</div><div class="ttdef"><b>Definition</b> thread_pool.hpp:68</div></div>
<div class="ttc" id="aclassThreadSafeDeque_html"><div class="ttname"><a href="classThreadSafeDeque.html">ThreadSafeDeque</a></div><div class="ttdoc">Thread-safe work-stealing deque template.</div><div class="ttdef"><b>Definition</b> thread_safe_deque.hpp:51</div></div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="files"></a>
Project Files</h1>
<ul>
<li><b><span class="tt"><a class="el" href="thread__pool_8hpp.html" title="C++20 work-stealing thread pool implementation.">src/core/thread_pool.hpp</a></span>:</b> Core work-stealing thread pool implementation</li>
<li><b><span class="tt"><a class="el" href="thread__safe__deque_8hpp.html" title="Thread-safe work-stealing deque declaration.">src/core/thread_safe_deque.hpp</a></span>:</b> Thread-safe LIFO/FIFO deque primitive</li>
<li><b><span class="tt"><a class="el" href="convolution_8hpp.html" title="3D volumetric convolution tasks for parallel image filtering.">src/3d_convolution/convolution.hpp</a></span>:</b> 3D convolution task and helper functions</li>
<li><b><span class="tt"><a class="el" href="main_8cpp.html" title="Main entry point for the 3D volumetric filtering demo.">src/3d_convolution/main.cpp</a></span>:</b> Demo program entry point</li>
<li><b><span class="tt">Doxyfile</span>:</b> Doxygen configuration for generating HTML documentation</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="building"></a>
Building &amp; Running</h1>
<h3 class="doxsection"><a class="anchor" id="autotoc_md12"></a>
Prerequisites</h3>
<ul>
<li>C++20 capable compiler (GCC 10+, Clang 12+, MSVC 2019+)</li>
<li>CMake (optional, or use direct compilation)</li>
<li>Doxygen (for documentation generation)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md13"></a>
Compilation</h3>
<div class="fragment"><div class="line">cd /path/to/work-stealing-thread-pool</div>
<div class="line">g++ -std=c++20 -O3 -pthread src/3d_convolution/main.cpp -o demo</div>
</div><!-- fragment --><p>Or with clang: </p><div class="fragment"><div class="line">clang++ -std=c++20 -O3 -pthread src/3d_convolution/main.cpp -o demo</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md14"></a>
Running</h3>
<div class="fragment"><div class="line">./demo</div>
</div><!-- fragment --><p>Expected output: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classThreadPool.html">ThreadPool</a> starting with 4 worker threads.</div>
<div class="line">Input initialized with background (10.0), central cube (100.0), AND Gaussian noise (stdev=8).</div>
<div class="line"> </div>
<div class="line">[Filter: 3D Gaussian Blur (Noise Reduction)] Submitted 22 tasks.</div>
<div class="line">Time taken <span class="keywordflow">for</span> parallel processing: XXX ms</div>
<div class="line">... (more filter outputs)</div>
<div class="line"> </div>
<div class="line">All filtering complete. The <a class="code hl_class" href="classThreadPool.html">ThreadPool</a> destructor will now run.</div>
<div class="line"><a class="code hl_function" href="classThreadPool.html#a3225e86aa7835545b3f6c2c8d363d5e5">ThreadPool</a> shutting down cleanly. All jthreads joined.</div>
<div class="ttc" id="aclassThreadPool_html_a3225e86aa7835545b3f6c2c8d363d5e5"><div class="ttname"><a href="classThreadPool.html#a3225e86aa7835545b3f6c2c8d363d5e5">ThreadPool::ThreadPool</a></div><div class="ttdeci">ThreadPool()</div><div class="ttdoc">Construct a ThreadPool with worker threads.</div><div class="ttdef"><b>Definition</b> thread_pool.hpp:178</div></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md15"></a>
Documentation</h3>
<div class="fragment"><div class="line">doxygen Doxyfile</div>
<div class="line">open docs/doxygen/html/index.html</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="learning_outcomes"></a>
Learning Outcomes</h1>
<p>By studying this project, you will understand:</p><ol type="1">
<li><b>Work-Stealing Algorithms:</b> How load-balancing queues improve performance</li>
<li><b>C++20 Concurrency:</b> Modern thread management with jthreads and stop tokens</li>
<li><b>Lock-Free Programming:</b> Atomic operations and minimal synchronization</li>
<li><b>Task Parallelism:</b> Decomposing problems into independent, parallelizable units</li>
<li><b>Cache Locality:</b> Why LIFO scheduling for local work matters</li>
<li><b>3D <a class="el" href="convolution_8hpp.html#a72c2e5fd5a8c2877abda19fb9bde6e4d" title="Type alias for 3D volume data.">Image</a> Processing:</b> Convolution kernels and their applications</li>
<li><b>RAII &amp; Modern C++:</b> Exception-safe resource management</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="future_work"></a>
Future Enhancements</h1>
<p>Potential extensions:</p><ul>
<li><b>GPU Acceleration:</b> CUDA/OpenCL backend for massive parallelism</li>
<li><b>Adaptive Task Sizing:</b> Dynamically split large tasks for better load balancing</li>
<li><b>Custom Allocators:</b> Pool-based memory allocation to reduce fragmentation</li>
<li><b>Profiling &amp; Metrics:</b> Detailed timing per worker thread and queue statistics</li>
<li><b>Generalized Kernels:</b> Template support for arbitrary kernel sizes</li>
<li><b>Batch Processing:</b> Queuing multiple volumes for pipeline parallelism</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="license"></a>
License</h1>
<p>This project is provided as-is for educational and research purposes.</p>
<h1 class="doxsection"><a class="anchor" id="author"></a>
Author &amp; Attribution</h1>
<p><b>Author:</b> dssregi <br  />
 <b>Date:</b> November 14, 2025 <br  />
 <b>Course:</b> Udemy C++ Advanced Concurrency &amp; Parallelism <br  />
</p>
<p>Inspired by work-stealing schedulers in languages like Cilk and Tokio. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
</div><!-- doc-content -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
